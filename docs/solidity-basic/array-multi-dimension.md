---
title: 多维数组
---

# 多维数组

前面的章节我们学习了数组，知道了数组是同类型元素的集合。我们暂时看到的都是一维数组。想象一下，假设你的合约不仅仅是管理一种NFT了， 而是管理多种NFT。比如说你同时持有多个Crypto Punk和多个Bored Ape。

![](./assets/array-multi-dimension/5db2a3f85c994d20ae85cdef38c9baaa.png)

如果你把他们的NFT ID全部放在同一个以为数组里面显然不太合适，因为Crypto Punk和Bored Ape都有ID为1001，1002，1003...的NFT。这个时候你就希望把它们分组。用一个数组专门记录Crypto Punk的NFT ID，另外一个数组用来专门记录Bored Ape的NFT ID。如下面的例子所示：

```solidity
// 分别记录两种NFT ID
uint[3] memory cryptoPunk = [uint(1001), 1002, 1003];
uint[5] memory boredApe = [uint(1001), 1002, 1003, 2001, 2002];

```

这种方法似乎解决了我们的问题，但是万一我某一天要买一种新的NFT怎么办？我的合约已经部署了，不能再更改了。所以这种方法也有不足之处，不能灵活新增NFT种类。这个时候我们就需要用到多维数组来完美解决这个问题。

## 多维数组的声明

多维数组也是同类型元素的集合。只不过它在这个基础上再分组而已。多维数组也有静态和动态之分：

* 静态多维数组 (_static multi-dimensional array_)
* 动态多维数组 (_dynamic multi-dimensional array_))

### 静态多维数组的声明

假设`T`是一种类型，那么静态多维数组的声明格式如下：

```solidity
T[col][row] dataLocation arrName;
```

其中`dataLocation`是数据位置，`arrName`是你为这个数组起的任意名字。而`row`和`col`则定义了你的多维数组有多少行和列。例如`uint[3][5]`就声明了一个5行3列的多维数组。如果你有学过其他语言，你会发现这样的声明方式跟其他语言是**恰恰相反**的。比如C语言和Javascript等在声明一个5行3列的多维数组，格式应该是`uint[5][3]`才对。这点要务必注意，尤其是在遍历多维数组的时候一不小心就搞反了。

:::caution
Solidity在声明多维数组的时候「行」和「列」跟C语言, Javascript等是相反的
:::

:::tip 声明静态多维数组
```solidity
uint[3][5] memory nftMem;
uint[3][5] storage nftStorage;
```
:::

### 动态多维数组的声明

假设`T`是一种类型，那么动态多维数组的声明格式如下：

```solidity
T[][] dataLocation arrName;
```

其中`dataLocation`是数据位置，而`arrName`是你为这个数组起的任意名字。虽然动态多维数组没有指定行和列，但是它的行为跟静态多维数组是一样的。也就是说它的行和列跟其他语言相比也是反的。

:::tip 声明动态多维数组
```solidity
uint[][] memory nftMem;
uint[][] storage nftStorage;
```
:::

## 多维数组的初始化

### 静态多维数组的初始化

静态多维数组的初始化和静态一维数组的初始化差不多

#### 零值初始化

如果你只声明了一个静态数组，那么它的所有元素都会被零值初始化（_zero value initialized_)。

:::tip 零值初始化整型数组
```solidity
uint[2][3] memory nftArr; //所有元素都是0
```
:::

#### 多维数组字面值初始化

你可以使用「多维数组字面值」对静态多维数组进行初始化。「多维数组字面值」的格式是`[[..],[..]]`，例如我们可以有`[[1,2,3],[4,5,6]`，也可以有`[['str1', 'str2', 'str3'],['str4']]`等等。下面的例子中我们用多维数组字面值初始化了一个整型数组：

:::tip 多维数组字面值初始化静态数组
```solidity
//必须使用uint(1000)显式地将「数组字面值」第一个元素的类型转换成uint
uint[3] memory nftArr = [uint(1000), 1001, 1002]; 
```
:::

要注意「数组字面值」的「基础类型」(_base type_)，是其第一个元素的类型。例如上面的例子中，`[uint(1000), 1001, 1002]`的基础类型是`uint`，因为第一个元素是`uint(1000)`。其他所有元素都会隐式地被转换成第一个元素的类型。

如果我们不强制将第一个元素转换成与我们所定义的数组的基础类型（在上面的例子中是`uint`）相同，那么编译器会报错。如下面的示例所示：

:::tip 「数组字面值」的「基础类型」需要和「数组」的「基础类型」相同
本示例编译期间会报错，类型不匹配。因为第一个元素会被隐式转换成能装得下它的最小整型，也就是`uint16`。与我们定义的数组的基础类型`uint`不匹配。
```solidity
// 编译报错，类型不匹配
uint[3] memory nftArr = [1000, 1001, 1002]; 
```
:::

另外要注意的一点是定义的数组长度必须跟数组字面值的长度是一样的，否则也会编译报错。如下面例子所示：

:::tip 定义的数组长度必须跟数组字面值的长度一致
数组定义的长度为3，但是数组字面值的长度为2
```solidity
uint[3] memory nftArr = [uint(1000), 1001];  //编译错误
```
:::

### 动态数组初始化

动态数组初始化需要使用到`new`关键字。其所有元素值被初始化为零值（_zero-value_)。如下所示，初始化了一个整型动态数组：

:::tip 动态数组初始化
初始化了一个有三个元素的动态数组，元素值被初始化为零值
```solidity
uint n = 3;
uint[] memory nftArr = new uint[](n);
```
:::

## 下标访问

跟大多数的编程语言一样，你也可以对Solidity的数组进行下标访问。下标访问所使用的操作符是`[]`，下标索引从`0`开始。

:::tip 数组的下标访问
```solidity
// 下标访问静态字节数组
uint[3] memory nftArr1 = [uint(1000), 1001, 1002];
nftArr1[0] = 2000;
nftArr1[1] = 2001;
nftArr1[2] = 2002;

// 下标访问动态字节数组
uint[] memory nftArr2 = new uint[](n);
nftArr2[0] = 1000;
nftArr2[1] = 1001;
nftArr2[2] = 1002;
```
:::


